Обо мне: Система записи и воспроизведения игровых данных.

Оценка качества
{
Архитектура: Достаточно атомарная архитектура для записи сцен с большим количеством элементов.
Но на данном этапе проработки может помешать человеческий фактор во время работы с DataID.

Производительность: Работоспособно. За подробностями и возможностью улучшения смотреть: "Оптимизация производительности" в "TODO".
}

Зависимости:
Utilities => Tickers
Utilities => ValueProviders
Utilities => ListExtensions

Настройка в проекте:
1.Создаётся ReplayController
2.Создаются RecordingSystem и PlaybackingSystem и пробрасываются в ReplayController
3.На сцене у объекта(Пример:игрока) создаётся RecordableTarget(и/или PlaybackableTarget если нужно проигрывание(проигрывание может быть у другого объекта)).
4.Выставляется TargetDataID, по которому записывается объект.
(таким образом при одинаковом ID PlaybackableTarget и RecordableTarget берут и записывают данные из одной и той же ячейки)
5.Для каждого желаемого записанного значения у цели(Игрока) создаётся RecordableValue, каждый их которых имеет ссылку на свой IValueProvider
(То есть если хотим записать PositionAndRotation, то в RecordableValue.IValueProvider прокидываем PositionAndRotationValueProvider)
Это RecordableValue добавляется в RecordableTarget._recordableValues

Работа:
У ReplayController надо вызвать метод StartRecording() =>
Надо изменить отслеживаемые значения у Recordable объекта => 
ReplayController.StopRecording() =>
ReplayController.StartPlaybacking() =>
Наблюдать за повторением изменения записанных значений Playbackable объекта.



TODO
{
Проверки на null. Пояснение: Если RecordableSystem или RecordableTarget или RecordableValue получает null в StartRecord() - логика этого не обработана.

Оптимизация производительности:
{==
2.1 Сделать систему instanceID на словарях для экономии памяти.
2.2 Остлеживать когда значения меняются, а когда нет. И в промежутки бездействия не записывать данные.
2.3 (impossible for me)Сейчас происходит boxing/unboxing при передачи структур через интерфейс. Понять как этого избежать.
2.4 Прекращать запись при Destroy(отгрузке или удалении) элемента
==}

Сделать возможность добавлять recordable/playbackable элементы даже после начала записи/проигрывания.(для того чтобы подгруженные во время записи объекты тоже проигрывались)

Пробрасывать RecodableTarget в RecordingSystem через инжект автоматически при появлении объекта.

Автоматическая выдача DataID, чтобы снизить человеческий фактор.(или обновляемый в ручную Enum для этого)

Добавить возможность BreakPlaybacking. Крч выйти из повтора преждевременно.

С помощью наследования и полиморфизма уменьшить количество ctrl+c, ctrl+v. И прибраться в порядке полей в классах.

PlaybackableValue.SetValueWithEnterpolation();

Добавить возможность пробрасывать в интерфейсы в unity. И после этого IValueProvider поменять из абстрактного класса обратно на интерфейс.

Когда-нибудь дойдём до ошибки переполнения стека или листа. Это надо отслеживать.

Сериализация и десерилизация записей.
}
